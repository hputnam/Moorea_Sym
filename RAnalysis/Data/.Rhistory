matrix (unlist (lapply (1 : num.boot, function (temp.boot) {
sapply (temp.m, function (temp.point) {
sum (temp.f1 [[temp.boot]] <= temp.point &
(temp.f2 [[temp.boot]] > temp.point |
is.na (temp.f2 [[temp.boot]])),
na.rm = TRUE)
})
})),
ncol = num.boot)
# Finding doubletons (f2) at each sampling point
temp.f2 =
matrix (unlist (lapply (1 : num.boot, function (temp.boot) {
sapply (temp.m, function (temp.point) {
sum (temp.f2 [[temp.boot]] <= temp.point &
(temp.f3 [[temp.boot]] > temp.point |
is.na (temp.f3 [[temp.boot]])),
na.rm = TRUE)
})
})),
ncol = num.boot)
# Finding projected unobserved diversity (f0) at each sampling point
temp.f0 = (temp.f1 * (temp.f1 - 1)) / (2 * (temp.f2 + 1))
# Finding projected lower diversity bound at each sampling point
temp.proj = temp.obs + temp.f0
return (list ('spp.rare' = temp.obs,
'f0'       = temp.f0,
'f1'       = temp.f1,
'f2'       = temp.f2,
'spp.proj' = temp.proj))
}
# Function to estimate coverage based on the algorithmic suggestion
# NOTE:  Chao presents a standard and an improved estimator. Here we chose the improved as suggested by Chao
EstimateCoverage =
function (temp.data, temp.m, temp.f1, temp.f2) {
temp.m   = matrix (rep (temp.m,
times = ncol (temp.f1)),
ncol = ncol (temp.f1))
temp.cov =
1 - temp.f1 / temp.m *
(((temp.m - 1) * temp.f1) /
((temp.m - 1) * temp.f1 + 2 * temp.f2))
return (list ('cov.rare' = temp.cov))
}
# Function to calculate means and variance (or standard errors) for data
# NOTE:  I need to create an additional function to do more bootstrapping
# and calculate confidence intervals as suggested in Chao 2012
# NOTE:  This has not been optimized and I don't use it currently
CalcSummary =
function (temp.data) {
temp.mean = apply (temp.data, 1, mean)
temp.var  = apply (temp.data, 1, var)
temp.se   = 1.96 * apply (temp.data, 1, sd) / sqrt (nrow (temp.data))
cbind ('Lower Var' = temp.mean - temp.var,
'Mean'  = temp.mean,
'Upper Var' = temp.mean + temp.var)
}
# Function to conduct all analyses from Chao 2012 and 2009
# NOTE:  Potential to address jagadness with more bootstrapping
# NOTE:  We used algorithmic calculation, rather than the analytical
# because we're working with such large numbers (i.e., choose (n, k) for
# n = 200k and k = 100's is infinite).
ChaoAnalysis =
function (data.boot) {
# Sampling points (to speed up analysis)
data.sample    = SamplePoints (data.boot)
# Observed and projected diversity, f0, f1, f2
data.diversity = CalcDiversity (data.boot,
data.sample [['m']])
# Estimated coverage for observed data
data.estcov    = EstimateCoverage (data.boot,
data.sample [['m']],
data.diversity [['f1']],
data.diversity [['f2']])
return (list ('n'        = data.sample [['n']],
'm'        = data.sample [['m']],
'mstar'    = data.sample [['mstar']],
'f0'       = data.diversity [['f0']],
'f1'       = data.diversity [['f1']],
'f2'       = data.diversity [['f2']],
'spp.proj' = data.diversity [['spp.proj']],
'spp.rare' = data.diversity [['spp.rare']],
'cov.rare' = data.estcov [['cov.rare']]))
}
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
temp.otu <- as.matrix(data.ngs)
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
rownames (temp.otu)
# Total diversity bootstraps
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
View(temp.data)
data.ngs <- temp.data[-1,-1]
View(data.ngs)
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
# Bootstrapping the data prior to calculations
# Setting the data for detailed analyses
temp.otu <- as.matrix(data.ngs)
# Other critical objects
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
# Total diversity bootstraps
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
Sample.Info <- read.csv("20140819_Envt_Data.csv", header=TRUE, sep=",") # loads data from a csv file with header seperated by commas
Taxa.Abund <- read.csv("20140819_Sym_Rarefaction.csv", row.names=1, header=FALSE, sep=",")  #read in sym "OTU" data with species and sample ID
View(Taxa.Abund)
# Libraries
library (parallel)
library (rbenchmark)
# Loading precalculated data
setwd ('/Users/hputnam/Publications/In_Prep/Primary/3_Moorea_NGS/RAnalysis/Data')
#--------------------------------------------------------------------------------
# Preliminary Steps
#--------------------------------------------------------------------------------
# Preparing Data
# NOTE:  data needs to follow a few rules to work this code
#    1. Coral species names need to be in the first row
#    2. Symbiodinium sequence identities need to be in the first column
# Load Data
Sample.Info <- read.csv("20140819_Envt_Data.csv", header=TRUE, sep=",") # loads data from a csv file with header seperated by commas
Taxa.Abund <- read.csv("20140819_Sym_Rarefaction.csv", row.names=1, header=FALSE, sep=",")  #read in sym "OTU" data with species and sample ID
# Importing sampling data
temp.data <- Taxa.Abund
#data.ngs
data.ngs <- temp.data[,-1]
# Importing coral species identities
temp.ids <- Taxa.Abund[1,]
# Importing symbiont clade identities
temp.names <- Taxa.Abund[, 1]
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
# Bootstrapping the data prior to calculations
# Setting the data for detailed analyses
temp.otu <- as.matrix(data.ngs)
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
# Total diversity bootstraps
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
spp.total  = length (boot.spp)
time.total = proc.time () [3]
data.spp   =
lapply (1 : spp.total, function (temp.index) {
time.run   = proc.time () [3]
temp.data  = ChaoAnalysis (boot.spp [[temp.index]])
print (sprintf ('Time for species:  %s',
signif ((proc.time () [3] - time.run) / 60,
digits = 2)))
print (sprintf ('Total time:  %s',
signif ((proc.time () [3] - time.total) / 60,
digits = 2)))
print (sprintf ('Total progress:  %s',
signif (temp.index / spp.total,
digits = 2)))
print ('')
return (temp.data)
})
names (data.spp) = names (boot.spp)
load("/Users/hputnam/MyProjects/Moorea_Sym/RAnalysis/Data/Moorea_sym.RData")
