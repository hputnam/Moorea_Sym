}
# Function to conduct all analyses from Chao 2012 and 2009
# NOTE:  Potential to address jagadness with more bootstrapping
# NOTE:  We used algorithmic calculation, rather than the analytical
# because we're working with such large numbers (i.e., choose (n, k) for
# n = 200k and k = 100's is infinite).
ChaoAnalysis =
function (data.boot) {
# Sampling points (to speed up analysis)
data.sample    = SamplePoints (data.boot)
# Observed and projected diversity, f0, f1, f2
data.diversity = CalcDiversity (data.boot,
data.sample [['m']])
# Estimated coverage for observed data
data.estcov    = EstimateCoverage (data.boot,
data.sample [['m']],
data.diversity [['f1']],
data.diversity [['f2']])
return (list ('n'        = data.sample [['n']],
'm'        = data.sample [['m']],
'mstar'    = data.sample [['mstar']],
'f0'       = data.diversity [['f0']],
'f1'       = data.diversity [['f1']],
'f2'       = data.diversity [['f2']],
'spp.proj' = data.diversity [['spp.proj']],
'spp.rare' = data.diversity [['spp.rare']],
'cov.rare' = data.estcov [['cov.rare']]))
}
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
# Bootstrapping the data prior to calculations
# Setting the data for detailed analyses
temp.otu <- data.ngs
# Other critical objects
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
boot.total
boot.spp =
lapply (temp.names, function (temp.name) {         # OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.otu) == temp.name)
BootstrapObs (temp.data = temp.otu [temp.index, ],
num.bootstrap = num.boot)
})
names (boot.spp) = temp.names
# Setting the data for detailed analyses
temp.otu <- as.numeric(data.ngs)
temp.otu <- as.matrix(data.ngs)
View(temp.otu)
boot.spp =
lapply (temp.names, function (temp.name) {         # OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.otu) == temp.name)
BootstrapObs (temp.data = temp.otu [temp.index, ],
num.bootstrap = num.boot)
})
names (boot.spp) = temp.names
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
#----------------------      Ofu Sample Completeness      -----------------------
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# NOTE:  interpolation = on; extrapolation = off
rm (list = ls ())
# Libraries
library (parallel)
library (rbenchmark)
# Loading precalculated data
setwd ('/Users/hputnam/Publications/In_Prep/Primary/3_Moorea_NGS/RAnalysis/Data')
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Preliminary Steps
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Preparing Data
# NOTE:  data needs to follow a few rules to work this code
#    1. Coral species names need to be in the first row
#    2. Symbiodinium sequence identities need to be in the first column
# Load Data
Sample.Info <- read.csv("20140819_Envt_Data.csv", header=TRUE, sep=",") # loads data from a csv file with header seperated by commas
Taxa.Abund <- read.csv("20140819_Sym_Rarefaction.csv", row.names = 1, header=FALSE, sep=",")  #read in sym "OTU" data with species and sample ID
View(Taxa.Abund)
# Importing sampling data
temp.data <- Taxa.Abund
#data.ngs
data.ngs <- temp.data
temp.ids <- Taxa.Abund[1,]
temp.names <- Taxa.Abund[, 1]
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
#----------------------      Ofu Sample Completeness      -----------------------
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# NOTE:  interpolation = on; extrapolation = off
rm (list = ls ())
# Libraries
library (parallel)
library (rbenchmark)
# Loading precalculated data
setwd ('/Users/hputnam/Publications/In_Prep/Primary/3_Moorea_NGS/RAnalysis/Data')
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Preliminary Steps
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Preparing Data
# NOTE:  data needs to follow a few rules to work this code
#    1. Coral species names need to be in the first row
#    2. Symbiodinium sequence identities need to be in the first column
# Load Data
Sample.Info <- read.csv("20140819_Envt_Data.csv", header=TRUE, sep=",") # loads data from a csv file with header seperated by commas
Taxa.Abund <- read.csv("20140819_Sym_Rarefaction.csv", header=FALSE, sep=",")  #read in sym "OTU" data with species and sample ID
# Importing sampling data
temp.data <- Taxa.Abund
#data.ngs
data.ngs <- temp.data
# Importing coral species identities
temp.ids <- Taxa.Abund[1,]
# Importing symbiont clade identities
temp.names <- Taxa.Abund[, 1]
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Functions
#--------------------------------------------------------------------------------
# NOTE:  All equations found in Chao 2012 and Chao 2009 (check in that order
# since most information is from Chao 2012)
# Function to bootstrap by individual Symbiodinium
# NOTE:  I should test whether the metrics are sensitive to sampling WITH
# replacement. I think that this could fix "necessarily" drawing rare types
# in the last few pulls and metrics may asymptote earlier.
BootstrapObs =
function (temp.data, num.bootstrap) {
# Prepping data
if (is.null (nrow (temp.data))) {
temp.data = temp.data [which (is.na (temp.data) == FALSE)]
} else {
temp.data = colSums (temp.data,
na.rm = TRUE)
}
# Creating symbiont pool to sample
temp.pool = rep (x     = 1 : length (temp.data),
times = temp.data)
# Bootstrapping symbiont observations
temp.rare =
lapply (1 : num.bootstrap, function (null) {
sample (x = temp.pool) # currently happening without replacement, but matches the way Chao recommends
})
temp.rare = matrix (unlist (temp.rare),
ncol = num.bootstrap)
return (temp.rare)
}
# Function to find sampling points (m) to analyze where n is the total
# number of samples
SamplePoints =
function (temp.data) {
# Total samples
temp.n = nrow (temp.data)
# Sampling points to analyze
# Greater resolution where slopes are greatest and completeness
# saturates
temp.m = unlist (list (1 : 19,
seq (from = 20,
to   = 180,
by   = 20),
seq (from = 200,
to   = 450,
by   = 50),
seq (from = 500,
to   = 900,
by   = 100),
seq (from = 1000,
to   = 2250,
by   = 250),
seq (from = 2500,
to   = 9500,
by   = 500),
seq (from   = 10000,
to     = temp.n,
length = resolution)))
temp.m = unique (sort (temp.m [which (temp.m <= temp.n)]))
return (list ('n' = temp.n,
'm' = temp.m))
}
# Function to find singletons and doubletons; unobserved species diversity;
# expected species diversity; estimated sampling coverage
# NOTE:  could look for speedups again because this function takes the longest
CalcDiversity =
function (temp.data, temp.m) {
# Data preparation
temp.seqs = unique (temp.data [, 1])
# Finding first instance of each species
temp.f1 =
lapply (1 : num.boot, function (temp.boot) {
temp = temp.data [, temp.boot]
temp =
lapply (temp.seqs, function (temp.seq) {
match (x = temp.seq,
table = temp)
})
unlist (temp)
})
# Finding second instance of each species
temp.f2 =
lapply (1 : num.boot, function (temp.boot) {
temp = temp.data [, temp.boot]
temp [temp.f1 [[temp.boot]]] = - 999
temp =
lapply (temp.seqs, function (temp.seq) {
match (x = temp.seq,
table = temp)
})
unlist (temp)
})
# Finding third instance of each species
temp.f3 =
lapply (1 : num.boot, function (temp.boot) {
temp = temp.data [, temp.boot]
temp [temp.f1 [[temp.boot]]] = - 999
temp [temp.f2 [[temp.boot]]] = - 999
temp =
lapply (temp.seqs, function (temp.seq) {
match (x = temp.seq,
table = temp)
})
unlist (temp)
})
# Finding total observed species diversity at each sampling point
temp.obs =
matrix (unlist (lapply (temp.f1, function (temp.boot) {
sapply (temp.m, function (temp.point) {
sum (temp.boot <= temp.point,
na.rm = TRUE)
})
})),
ncol = num.boot)
# Finding singletons (f1) at each sampling point
temp.f1 =
matrix (unlist (lapply (1 : num.boot, function (temp.boot) {
sapply (temp.m, function (temp.point) {
sum (temp.f1 [[temp.boot]] <= temp.point &
(temp.f2 [[temp.boot]] > temp.point |
is.na (temp.f2 [[temp.boot]])),
na.rm = TRUE)
})
})),
ncol = num.boot)
# Finding doubletons (f2) at each sampling point
temp.f2 =
matrix (unlist (lapply (1 : num.boot, function (temp.boot) {
sapply (temp.m, function (temp.point) {
sum (temp.f2 [[temp.boot]] <= temp.point &
(temp.f3 [[temp.boot]] > temp.point |
is.na (temp.f3 [[temp.boot]])),
na.rm = TRUE)
})
})),
ncol = num.boot)
# Finding projected unobserved diversity (f0) at each sampling point
temp.f0 = (temp.f1 * (temp.f1 - 1)) / (2 * (temp.f2 + 1))
# Finding projected lower diversity bound at each sampling point
temp.proj = temp.obs + temp.f0
return (list ('spp.rare' = temp.obs,
'f0'       = temp.f0,
'f1'       = temp.f1,
'f2'       = temp.f2,
'spp.proj' = temp.proj))
}
# Function to estimate coverage based on the algorithmic suggestion
# NOTE:  Chao presents a standard and an improved estimator. Here we chose the improved as suggested by Chao
EstimateCoverage =
function (temp.data, temp.m, temp.f1, temp.f2) {
temp.m   = matrix (rep (temp.m,
times = ncol (temp.f1)),
ncol = ncol (temp.f1))
temp.cov =
1 - temp.f1 / temp.m *
(((temp.m - 1) * temp.f1) /
((temp.m - 1) * temp.f1 + 2 * temp.f2))
return (list ('cov.rare' = temp.cov))
}
# Function to calculate means and variance (or standard errors) for data
# NOTE:  I need to create an additional function to do more bootstrapping
# and calculate confidence intervals as suggested in Chao 2012
# NOTE:  This has not been optimized and I don't use it currently
CalcSummary =
function (temp.data) {
temp.mean = apply (temp.data, 1, mean)
temp.var  = apply (temp.data, 1, var)
temp.se   = 1.96 * apply (temp.data, 1, sd) / sqrt (nrow (temp.data))
cbind ('Lower Var' = temp.mean - temp.var,
'Mean'  = temp.mean,
'Upper Var' = temp.mean + temp.var)
}
# Function to conduct all analyses from Chao 2012 and 2009
# NOTE:  Potential to address jagadness with more bootstrapping
# NOTE:  We used algorithmic calculation, rather than the analytical
# because we're working with such large numbers (i.e., choose (n, k) for
# n = 200k and k = 100's is infinite).
ChaoAnalysis =
function (data.boot) {
# Sampling points (to speed up analysis)
data.sample    = SamplePoints (data.boot)
# Observed and projected diversity, f0, f1, f2
data.diversity = CalcDiversity (data.boot,
data.sample [['m']])
# Estimated coverage for observed data
data.estcov    = EstimateCoverage (data.boot,
data.sample [['m']],
data.diversity [['f1']],
data.diversity [['f2']])
return (list ('n'        = data.sample [['n']],
'm'        = data.sample [['m']],
'mstar'    = data.sample [['mstar']],
'f0'       = data.diversity [['f0']],
'f1'       = data.diversity [['f1']],
'f2'       = data.diversity [['f2']],
'spp.proj' = data.diversity [['spp.proj']],
'spp.rare' = data.diversity [['spp.rare']],
'cov.rare' = data.estcov [['cov.rare']]))
}
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
temp.otu <- as.matrix(data.ngs)
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
rownames (temp.otu)
# Total diversity bootstraps
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
View(temp.data)
data.ngs <- temp.data[-1,-1]
View(data.ngs)
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
# Bootstrapping the data prior to calculations
# Setting the data for detailed analyses
temp.otu <- as.matrix(data.ngs)
# Other critical objects
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
# Total diversity bootstraps
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
Sample.Info <- read.csv("20140819_Envt_Data.csv", header=TRUE, sep=",") # loads data from a csv file with header seperated by commas
Taxa.Abund <- read.csv("20140819_Sym_Rarefaction.csv", row.names=1, header=FALSE, sep=",")  #read in sym "OTU" data with species and sample ID
View(Taxa.Abund)
# Libraries
library (parallel)
library (rbenchmark)
# Loading precalculated data
setwd ('/Users/hputnam/Publications/In_Prep/Primary/3_Moorea_NGS/RAnalysis/Data')
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Preliminary Steps
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Preparing Data
# NOTE:  data needs to follow a few rules to work this code
#    1. Coral species names need to be in the first row
#    2. Symbiodinium sequence identities need to be in the first column
# Load Data
Sample.Info <- read.csv("20140819_Envt_Data.csv", header=TRUE, sep=",") # loads data from a csv file with header seperated by commas
Taxa.Abund <- read.csv("20140819_Sym_Rarefaction.csv", row.names=1, header=FALSE, sep=",")  #read in sym "OTU" data with species and sample ID
# Importing sampling data
temp.data <- Taxa.Abund
#data.ngs
data.ngs <- temp.data[,-1]
# Importing coral species identities
temp.ids <- Taxa.Abund[1,]
# Importing symbiont clade identities
temp.names <- Taxa.Abund[, 1]
# Setting analysis parameters
set.seed (999)
num.boot   = 10
resolution = 1
# Bootstrapping the data prior to calculations
# Setting the data for detailed analyses
temp.otu <- as.matrix(data.ngs)
temp.clades = c ('A', 'C', 'D', "F", "G", "I")
temp.names  = sort (unique (rownames (temp.otu)))
# Total diversity bootstraps
boot.total =
lapply (data.ngs, function (temp.data) {          # OPTIONAL MCLAPPLY
BootstrapObs (temp.data     = temp.data,
num.bootstrap = num.boot)
})
names (boot.total) = c ('Data')
boot.clade =
lapply (temp.clades, function (temp.clade) {
# Modifying data
temp.index = which (colnames (temp.otu) == temp.clade)
temp.data  = temp.otu [, temp.index]
temp.index = which (rowSums (temp.data) > 0)
temp.data  = temp.data [temp.index, ]
# Bootstrapping for each coral species
temp.boot =
lapply (temp.names, function (temp.name) {# OPTIONAL MCLAPPLY
temp.index = which (rownames (temp.data) == temp.name)
BootstrapObs (temp.data = temp.data [temp.index, ],
num.bootstrap = num.boot)
})
names (temp.boot) = temp.names
return (temp.boot)
})
names (boot.clade) = temp.clades
spp.total  = length (boot.spp)
time.total = proc.time () [3]
data.spp   =
lapply (1 : spp.total, function (temp.index) {
time.run   = proc.time () [3]
temp.data  = ChaoAnalysis (boot.spp [[temp.index]])
print (sprintf ('Time for species:  %s',
signif ((proc.time () [3] - time.run) / 60,
digits = 2)))
print (sprintf ('Total time:  %s',
signif ((proc.time () [3] - time.total) / 60,
digits = 2)))
print (sprintf ('Total progress:  %s',
signif (temp.index / spp.total,
digits = 2)))
print ('')
return (temp.data)
})
names (data.spp) = names (boot.spp)
