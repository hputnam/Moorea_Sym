---
title: "data_analysis.Rmd"
author: "Ross Cunning, Hollie Putnam, Danielle Claar"
date: "6/13/2017"
output: html_document
---

## Load packages and set options
```{r setup, include=FALSE}
# Load libraries
library(phyloseq)
library(multcompView)
library(seqinr)
library(phangorn) 
library(caroline)
library(fmsb)
library(vegan)
library(lme4)
library(MuMIn)
library(png)
library(pixmap)

# Set options
options(stringsAsFactors = FALSE)

# Set colors for plotting
sitecolors <- c("#762a83", "#9970ab", "#c2a5cf", "#a6dba0", "#5aae61", "#1b7837")
taxcolors <- matrix(c("#d9d9d9", "#ffffb3", "#fb8072"), 
                    dimnames=list(c("CladeA", "CladeC", "CladeD")))
```

# Analyze temperature regimes at each site

## Temperature data summary
```{r temp_data}
# Load temperature data
load("tempdata.RData") # loads the temperature data from temperature_analysis

# Plot temperature distributions for each site
par(mfrow=c(2,3), mar=c(3,3,2,2), mgp=c(1.5,0.1,0), tcl=-0.2)
hist(temp.all$Site.1, xlim=c(25,32), breaks=seq(25,32,0.25), 
     main="Site 1", xlab="Temp ?C")
hist(temp.all$Site.2, xlim=c(25,32), breaks=seq(25,32,0.25), 
     main="Site 2", xlab="Temp ?C")
hist(temp.all$Site.3, xlim=c(25,32), breaks=seq(25,32,0.25), 
     main="Site 3", xlab="Temp ?C")
hist(temp.all$Site.7, xlim=c(25,32), breaks=seq(25,32,0.25), 
     main="Site 7", xlab="Temp ?C")
hist(temp.all$Site.8, xlim=c(25,32), breaks=seq(25,32,0.25), 
     main="Site 8", xlab="Temp ?C")
hist(temp.all$Site.9, xlim=c(25,32), breaks=seq(25,32,0.25), 
     main="Site 9", xlab="Temp ?C")

# View Descriptive Stats
temp.summ
```

## Multivariate temperature analysis
### Principal component analysis
```{r temp_pca}
# Principal component analysis of temperature metrics

## Set which temperature metrics to include in PCA
include <- c("mean", "var", "dip", "daily.mean.min", 
             "daily.mean.max", "daysover30", "daysunder27")

## Subset temperature metrics for PCA
temp <- as.data.frame(temp.summ[, include])

## Run PCA
pca.temp <- prcomp(temp, scale=TRUE)
par(mfrow=c(1,1))
screeplot(pca.temp)

## Calculate loading values of original metrics
aload <- abs(pca.temp$rotation)
sweep(aload, 2, colSums(aload), "/")

## Extract temperature PC values for each site
temp.PCs <- pca.temp$x

## Visualize PCA as biplot
biplot(pca.temp)
```

### Temperature regime radar chart
```{r}
# Calculate ranges of each column
temp2 <- rbind(apply(temp, 2, function(x) rev(range(x))), temp)
# Reorder columns
temp2 <- temp2[, c(3,4,1,6,2,5,7)]
# Plot radar chart
rad <- radarchart(
  temp2,
  
  #custom polygon
  plwd=4, plty=1,
  
  #custom colors
  pcol=sitecolors,
  pfcol=scales::alpha(sitecolors, 0.25),
 
  #custom the grid
  cglcol="grey", cglty=1, axislabcol="grey", cglwd=0.8,
 
  #custom labels
  vlcex=0.8 
)

legend("topright", rownames(temp2)[-(1:2)], lty=1, lwd=2, col=sitecolors, bty="n")

```

# Figure 1
```{r Fig1}
png("Output/Fig1.png", width=7, height=2.5, units="in", res=300)
par(mfrow=c(1,3), mgp=c(1,0.1,0), tcl=0.25, cex.lab=1, cex.axis=0.8,
    mar=c(2,2,2,2))



# Panel A
#### MAP OF MOOREA SHOWING SITE LOCATIONS
plot(NA)

# Panel B
biplot(pca.temp, cex=0.8, bty="n", xpd=NA)
title("B.", adj=0)

# Panel C
par(mar=c(0,0,0,0), xpd=NA)
rad <- radarchart(
  temp2,
  
  #custom polygon
  plwd=2, plty=1,
  
  #custom colors
  pcol=sitecolors,
  pfcol=scales::alpha(sitecolors, 0.25),
 
  #custom the grid
  cglcol="grey", cglty=1, axislabcol="grey", cglwd=0.8,
 
  #custom labels
  vlcex=0.8 
)
title("C.", adj=0)
legend("topright", rownames(temp2)[-(1:2)], lty=1, lwd=2, col=sitecolors, bty="n", 
       cex=0.6, ncol=2, inset=c(0.02,0.06))
dev.off()
```


# Analyze *Symbiodinium* communities

## Load *Symbiodinium* data
```{r load_sym}
# Load Symbiodinium data from saved phyloseq objects
load("Data/Moorea_sym100_f.RData")  # loads phyloseq object for 100% OTUs named phy.f
phy100.f <- phy.f # renames to phy100.f
load("Data/Moorea_sym_f.RData")  # loads phyloseq object for 97%-within-sample OTUs named phy.f

# Append site temperature metrics to sample_data in phyloseq objects
site.levels <- as.numeric(sample_data(phy.f)$Site)
sample_data(phy.f)$mean <- temp[site.levels, "mean"]
sample_data(phy.f)$var <- temp[site.levels, "var"]
sample_data(phy.f)$dip <- temp[site.levels, "dip"]
sample_data(phy.f)$daily.mean.min <- temp[site.levels, "daily.mean.min"]
sample_data(phy.f)$daily.mean.max <- temp[site.levels, "daily.mean.max"]
sample_data(phy.f)$daysover30 <- temp[site.levels, "daysover30"]
sample_data(phy.f)$daysunder27 <- temp[site.levels, "daysover30"]

# Append site temperature PCs to sample_data in phyloseq objects
sample_data(phy.f)$PC1 <- temp.PCs[site.levels, "PC1"]
sample_data(phy.f)$PC2 <- temp.PCs[site.levels, "PC2"]
sample_data(phy.f)$PC3 <- temp.PCs[site.levels, "PC3"]
sample_data(phy.f)$PC4 <- temp.PCs[site.levels, "PC4"]
sample_data(phy100.f)$PC1 <- temp.PCs[site.levels, "PC1"]
sample_data(phy100.f)$PC2 <- temp.PCs[site.levels, "PC2"]
sample_data(phy100.f)$PC3 <- temp.PCs[site.levels, "PC3"]
sample_data(phy100.f)$PC4 <- temp.PCs[site.levels, "PC4"]

# Convert OTU counts to proportions (relative abundances)
phy.f.p <- transform_sample_counts(phy.f, function(x) x/sum(x))
phy100.f.p <- transform_sample_counts(phy100.f, function(x) x/sum(x))
# Square-root transform relative abundances
transform <- function(x) sqrt(x/sum(x))  # Set transformation function
phy.f.t <- transform_sample_counts(phy.f, transform)  # Transform data
phy100.f.t <- transform_sample_counts(phy100.f, transform)  # Transform data
```

## Visualize *Symbiodinium* clade abundances
The relative abundance of each clade in the entire dataset (normalized for differences in sequencing depth across samples).
```{r Fig2}
cladeAbund <- aggregate(data.frame(RelAbund=rowSums(otu_table(phy.f.p))),
                        by=list(Clade=data.frame(tax_table(phy.f.p))$Clade), FUN=sum)
cladeAbund$Prop <- prop.table(cladeAbund$RelAbund)
cladeAbund[,-2]

composition <- function(phy, col, legend=T) {
  samdat <- data.frame(sample_data(phy))
  #samdat$Genus <- factor(samdat$Genus, levels=rev(levels(samdat$Genus)))
  samdat$Species <- factor(samdat$Species, levels=rev(levels(samdat$Species)))
  samdat$Site <- factor(samdat$Site, levels=rev(levels(samdat$Site)))
  samdat <- samdat[with(samdat, order(Species, Site, -DNA.ID)), ]
  typerelabund <- as.matrix(otu_table(phy)[order(data.frame(tax_table(phy))$hit), 
                                           rownames(samdat)])
  sitebreaks <- c(as.character(samdat$Site), "X")==c("X", as.character(samdat$Site))
  sitebreaks <- which(sitebreaks==F) - 1
  spbreaks <- c(which(duplicated(samdat$Species)==F) - 1, nrow(samdat))
  
  # Make Barplot
  par(mar=c(4,2,2,8))
  barplot(typerelabund, horiz=T, space=0, axes=F,axisnames=F, yaxs="i", col=col)
  rect(0, 0, par("usr")[2], par("usr")[4], lwd=1, xpd=T)
  axis(side=1, at=seq(0, 1, 0.2), line=0, tck=-0.02, mgp=c(0,0.25,0), cex.axis=0.8)
  mtext(side=1, "Relative abundance", cex=1, line=2)
  # Add legend
  if (legend==T) {
    legend(x=1.1, y=par("usr")[4]*0.90, xjust=0, yjust=0.1, bty="n", xpd=T, 
           cex=1, pt.cex=1, legend=c("Clade A", "Clade C", "Clade D"), 
           fill=taxcolors, y.intersp=0.7)
    legend(x=1.1, y=par("usr")[4]*0.725, xjust=0, yjust=0.1, bty="n", xpd=T, cex=1, 
           pt.cex=1, legend=c("Site 1", "Site 2", "Site 3", "Site 7", "Site 8", "Site 9"),
           fill=sitecolors, y.intersp=0.7)
  }
  # Add grouping bars for Site
  sitecolors <- matrix(sitecolors, 
              dimnames=list(c(" Site 1", " Site 2", " Site 3", 
                              " Site 7", " Site 8", " Site 9")))
  for (i in 1:(length(sitebreaks)-1)) {
    lines(c(0, 1), c(sitebreaks[i], sitebreaks[i]), lty=2, lwd=0.25)
    rect(1.01, sitebreaks[i], 1.05, sitebreaks[i+1],
         col=sitecolors[as.character(samdat$Site[sitebreaks[i]+1]),], 
         lwd=0.25, xpd=T)
  }
  
  # Add lines to separate species and species names
  for (i in 1:length(spbreaks)) {
    lines(c(-0.08, 1), c(spbreaks[i], spbreaks[i]), xpd=T, type="l", lwd=0.6)
  }
  text(-0.07, c(11,37), xpd=T, pos=4, cex=1.5, srt=90,
         labels=c(expression(italic("Porites")), 
                  expression(italic("Acropora"))))
  #for (i in 1:nrow(samdat)) {
  #  text(0, i-0.5, rownames(samdat)[i], xpd=T, cex=0.7, pos=2)
  #}
}

png("Output/Fig2.png", width=3.5, height=5, units="in", res=300)
par(mfrow=c(1,1), mar=c(2, 1.5, 2, 10), lwd=0.1, cex=0.7, xpd=NA)
# Plot composition of 97% within-sample OTUs colored by clade
composition(phy.f.p, col=taxcolors[factor(data.frame(tax_table(phy.f.p))[order(data.frame(tax_table(phy.f.p))$Subtype), ]$Clade, levels=c("A","C","D"))], legend=T)
dev.off()
```

## Build *Symbiodinium* phylogenetic tree
```{r tree}
#https://rdrr.io/rforge/seqinr/man/dist.alignment.html
#returns sqrt of pairwise genetic distance, then squared the matrices
A.seqs <- read.alignment(file = "Data/A_tree_seqs_aligned_clean.fasta", format= "fasta")
A.dis <- (as.matrix(dist.alignment(A.seqs, matrix = "identity" )))^2
write.csv(A.dis, file="Data/A.dis.matx.csv")

C.seqs <- read.alignment(file = "Data/C_tree_seqs_aligned_clean.fasta", format= "fasta")
C.dis <- (as.matrix(dist.alignment(C.seqs, matrix = "identity" )))^2
write.csv(C.dis, file="Data/C.dis.matx.csv")

D.seqs <- read.alignment(file = "Data/D_tree_seqs_aligned_clean.fasta", format= "fasta")
D.dis <- (as.matrix(dist.alignment(D.seqs, matrix = "identity" )))^2
write.csv(D.dis, file="D.dis.matx.csv")

#give clade distances using average 28s distance from Pochon and Gates 2010
A_C <- matrix(0.1960, ncol=ncol(A.dis), nrow=nrow(C.dis), dimnames=list(rownames(C.dis), colnames(A.dis))) 
A_D <- matrix(0.1775, ncol=ncol(A.dis), nrow=nrow(D.dis), dimnames=list(rownames(D.dis), colnames(A.dis)))
C_D <- matrix(0.1520, ncol=ncol(C.dis), nrow=nrow(D.dis), dimnames=list(rownames(D.dis), colnames(C.dis)))
  
#build ACD matrix
col1 <- rbind(A.dis, A_C, A_D)
col2 <- rbind(matrix(NA, nrow=nrow(A.dis), ncol=ncol(C.dis), dimnames=list(rownames(A.dis), colnames(C.dis))), C.dis, C_D)
col3 <- rbind(matrix(NA, nrow=nrow(A.dis)+nrow(C.dis), ncol=ncol(D.dis), dimnames=list(c(rownames(A.dis), rownames(C.dis)), colnames(D.dis))), D.dis)

ubermatrix <- cbind(col1, col2, col3)

#build tree
uber.tree <- phangorn::upgma(ubermatrix)

# Slot uber tree into the phy_tree slot of the phyloseq object
phy_tree(phy.f) <- phy_tree(uber.tree)
phy_tree(phy.f.p) <- phy_tree(uber.tree)
phy_tree(phy.f.t) <- phy_tree(uber.tree)
```

## Ordinate *Symbiodinium* communities
```{r sym_ordination}
par(lwd=1, cex=1)
# Separate Acropora and Porites
phy.f.t.porites <- subset_samples(phy.f.t,Species=="Porties")
phy.f.t.acropora <- subset_samples(phy.f.t,Species=="Acropora")

# Principal coordinate analysis using weighted UniFrac distances

## Acropora
acr.ufdist <- UniFrac(phy.f.t.acropora, weighted=T, normalized=F, parallel=F, fast=T)
acr.bd <- betadisper(d=acr.ufdist, group=sample_data(phy.f.t.acropora)$Site,
                       type="centroid", bias.adjust=FALSE)
plot(acr.bd, hull=F, label=F, col=sitecolors, seg.col=sitecolors,
     main=expression(italic(Acropora:~~Symbiodinium)~"PCoA"),
     xlab="PCoA 1", ylab="PCoA 2", sub="")
ordihull(acr.bd, sample_data(phy.f.t.acropora)$Site,  draw = c("polygon"),
         col = sitecolors, alpha=0.2, lwd=0.05)
legend("topright", bty="n", pch=1:6,
       legend=levels(sample_data(phy.f.t.acropora)$Site),
       col=sitecolors)

## Porites
por.ufdist <- UniFrac(phy.f.t.porites, weighted=T, normalized=F, parallel=F, fast=T)
por.bd <- betadisper(d=por.ufdist, group=sample_data(phy.f.t.porites)$Site,
                       type="centroid", bias.adjust=FALSE)
plot(por.bd, hull=F, label=F, col=sitecolors, seg.col=sitecolors,
     main=expression(italic(Porites:~~Symbiodinium)~"PCoA"),
     xlab="PCoA 1", ylab="PCoA 2", sub="")
ordihull(por.bd, sample_data(phy.f.t.porites)$Site,  draw = c("polygon"),
         col = sitecolors, alpha=0.2, lwd=0.05)
legend("topright", bty="n", pch=1:6,
       legend=levels(sample_data(phy.f.t.porites)$Site),
       col=sitecolors)
```

## Test for differences in community composition among sites
### (i.e., differences in multivariate *location*)
```{r permanova}
perms <- function(phy, group, trt) {
  groups <- data.frame(sample_data(phy))[, group]
  # Create data frame to populate with results
  resdf <- data.frame(
    matrix(ncol=7, nrow=nlevels(groups),
           dimnames=list(levels(data.frame(sample_data(phy))[, group]), 
                         c(group, "n", "overall", "within", "between", "R2", "p")))
  )
  # Compute within- and between-treatment statistics for each group
  for (i in 1:nlevels(groups)) {
    group.name <<- levels(groups)[i]
    resdf[i, group] <- group.name
    # make subsetted phyloseq object for individual group
    phy.group <- phy 
    samdat <- data.frame(sample_data(phy))
    sample_data(phy.group) <- sample_data(samdat[samdat[[group]]==group.name, ])
    samdat <- as(sample_data(phy.group), "data.frame") # sample data for subsetted phyloseq object
    # calculate distances
    ufdist <- phyloseq::distance(phy.group, "wunifrac")
    resdf$n[i] <- nsamples(phy.group)
    md <- meandist(ufdist, samdat[, trt])
    resdf$within[i] <- summary(md)$W  # Weighted mean dissimilarity within treatments
    resdf$between[i] <- summary(md)$B  # Mean dissimilarity between treatments
    resdf$overall[i] <- summary(md)$D  # Overall dissimilarity
    if (nlevels(as(sample_data(phy.group), "data.frame")[, trt]) > 1) {
      permanova <- adonis(ufdist ~ get(trt), data=samdat, permutations=99999)
      resdf$R2[i] <- permanova$aov.tab$"R2"[1]  # PERMANOVA partial R-squared
      resdf$p[i] <- permanova$aov.tab$"Pr(>F)"[1]  # PERMANOVA p-value
      #bd <- betadisper(ufdist, group=samdat[, trt])
      #resdf$bd[i] <- TukeyHSD(bd)$group[4]
    } else {
      resdf$R2[i] <- NA
      resdf$p[i] <- NA
      #resdf$bd[i] <- NA
    }
  }
  return(resdf)
}

perm.out <- perms(phy=phy.f.t, group="Species", trt="Site")
perm.out
```

## Test for differences in community variability among sites
### (i.e., differences in multivariate *dispersion*, or beta diversity)
```{r betadisper}
acr.bd.anova <- anova(acr.bd)
acr.bdsumm <- aggregate(data.frame(mean=as.vector(acr.bd$distances)),
                        by=list(group=acr.bd$group), FUN=mean)
acr.bdsumm$se <- aggregate(as.vector(acr.bd$distances), by=list(group=acr.bd$group), 
                           FUN=function(x) sd(x)/sqrt(length(x)))$x
# Use permutations to perform pairwise comparisons of group mean dispersions
acr.pt <- permutest(acr.bd, pairwise=T)
acr.bdsumm$l <- multcompLetters(acr.pt$pairwise$permuted)$Letters
  
with(acr.bdsumm, {
  plot(mean, type="n", ylim=c(0, 0.15), ylab="Distance to centroid", xaxt="n", 
       xlab="Site", main=expression(italic(Acropora:~Symbiodinium)~beta-diversity))
  arrows(1:6, mean - se, 1:6, mean + se, length=0.05, angle=90, code=3)
  points(1:6, mean, cex=1, pch=21, bg=sitecolors)
  axis(side=1, at=1:6, cex.axis=0.75, labels=group)
  text(1:6, mean+se+0.015, l, cex=0.8)
})


## Porites
por.bd.anova <- anova(por.bd)
por.bdsumm <- aggregate(data.frame(mean=as.vector(por.bd$distances)),
                        by=list(group=por.bd$group), FUN=mean)
por.bdsumm$se <- aggregate(as.vector(por.bd$distances), by=list(group=por.bd$group), 
                           FUN=function(x) sd(x)/sqrt(length(x)))$x
# Use permutations to perform pairwise comparisons of group mean dispersions
por.pt <- permutest(por.bd, pairwise=T)
por.bdsumm$l <- multcompLetters(por.pt$pairwise$permuted)$Letters
  
with(por.bdsumm, {
  plot(mean, type="n", ylim=c(0, 0.04), ylab="Distance to centroid", xaxt="n", 
       xlab="Site", main=expression(italic(Porites:~Symbiodinium)~beta-diversity))
  arrows(1:6, mean - se, 1:6, mean + se, length=0.05, angle=90, code=3)
  points(1:6, mean, cex=1, pch=21, bg=sitecolors)
  axis(side=1, at=1:6, cex.axis=0.75, labels=group)
  text(1:6, mean+se+0.005, l, cex=0.8)
})
```

# Figure 3
```{r Fig3}
png("Output/Fig3.png", width=4, height=4, units="in", res=300)
par(mfrow=c(2,2), mar=c(2,2,1,1), mgp=c(1.1,0.1,0), tcl=0.2, 
    cex.axis=0.8, cex.lab=1)

# Panel A
plot(acr.bd, hull=F, label=F, col=sitecolors, seg.col=sitecolors,
     xlab="Axis 1", ylab="Axis 2", main="", cex=1)
ordihull(acr.bd, sample_data(phy.f.t.acropora)$Site,  draw = c("polygon"),
         col = sitecolors, alpha=0.2, lwd=0.05)
legend("topright", bty="n", pch=1:6, cex=0.6,
       legend=levels(sample_data(phy.f.t.acropora)$Site),
       col=sitecolors)
#text(par("usr")[1], par("usr")[4], "A.", font=2, xpd=NA, pos=2, cex=1.25)
mtext(side=3, adj=-0.23, "A.", font=2)

# Panel B
with(acr.bdsumm, {
  plot(mean, type="n", ylim=c(0, 0.15), ylab="Distance to centroid", xaxt="n", 
       xlab="Site")
  arrows(1:6, mean - se, 1:6, mean + se, length=0.025, angle=90, code=3, lwd=0.5)
  points(1:6, mean, cex=1, pch=1:6, col=sitecolors, lwd=2)
  axis(side=1, at=1:6, cex.axis=0.75, labels=group)
  text(1:6, mean+se+0.01, l, cex=0.5)
})
#text(par("usr")[1]-0.3, par("usr")[4], "B.", font=2, xpd=NA, pos=2, cex=1.25)
mtext(side=3, adj=-0.25, "B.", font=2)

# Panel C
plot(por.bd, hull=F, label=F, col=sitecolors, seg.col=sitecolors,
     xlab="Axis 1", ylab="Axis 2", main="", cex=1)
ordihull(por.bd, sample_data(phy.f.t.porites)$Site,  draw = c("polygon"),
         col = sitecolors, alpha=0.2, lwd=0.05)
legend("topright", bty="n", pch=1:6, cex=0.6,
       legend=levels(sample_data(phy.f.t.porites)$Site),
       col=sitecolors)
#text(par("usr")[1], par("usr")[4], "C.", font=2, xpd=NA, pos=2, cex=1.25)
mtext(side=3, adj=-0.23, "C.", font=2)

# Panel D
with(por.bdsumm, {
  plot(mean, type="n", ylim=c(0, 0.04), ylab="Distance to centroid", xaxt="n", 
       xlab="Site")
  arrows(1:6, mean - se, 1:6, mean + se, length=0.025, angle=90, code=3, lwd=0.5)
  points(1:6, mean, cex=1, pch=1:6, col=sitecolors, lwd=2)
  axis(side=1, at=1:6, cex.axis=0.75, labels=group)
  text(1:6, mean+se+0.0035, l, cex=0.5)
})
#text(par("usr")[1]-0.3, par("usr")[4], "D.", font=2, xpd=NA, pos=2, cex=1.25)
mtext(side=3, adj=-0.25, "D.", font=2)
dev.off()
```

## What temperature metrics (models) carry the most weight in describing beta diversity?
```{r model testing}
ufdist <- UniFrac(phy.f.t, weighted=T, normalized=F, parallel=F, fast=T)
bd <- betadisper(d=ufdist, group=sample_data(phy.f.t)$Site,
                       type="centroid", bias.adjust=FALSE)

temp.var <- as.data.frame(sample_data(phy.f.t)[, "var"])
temp.mean <- as.data.frame(sample_data(phy.f.t)[, "mean"])
temp.dip <- as.data.frame(sample_data(phy.f.t)[, "dip"])
temp.do30 <- as.data.frame(sample_data(phy.f.t)[, "daysover30"])
temp.du27 <- as.data.frame(sample_data(phy.f.t)[, "daysunder27"])
temp.dmmax <- as.data.frame(sample_data(phy.f.t)[, "daily.mean.max"])
temp.dmmin <- as.data.frame(sample_data(phy.f.t)[, "daily.mean.min"])
species <- sample_data(phy.f.t)$Species
site <- sample_data(phy.f.t)$Site

hist(log(bd$distances))

mod.var <- lmer(log(bd$distances) ~ temp.var$var*species + 1|site)
mod.mean <- lmer(log(bd$distances) ~ temp.mean$mean*species + 1|site)
mod.dip <- lmer(log(bd$distances) ~ temp.dip$dip*species + 1|site)
mod.do30 <- lmer(log(bd$distances) ~ temp.do30$daysover30*species + 1|site)
mod.du27 <- lmer(log(bd$distances) ~ temp.du27$daysunder27*species + 1|site)
mod.dmmax <- lmer(log(bd$distances) ~ temp.dmmax$daily.mean.max*species + 1|site)
mod.dmmin <- lmer(log(bd$distances) ~ temp.dmmin$daily.mean.min*species + 1|site)

mod.test <- AICc(mod.do30, mod.du27,mod.var, mod.dip, mod.dmmax, mod.dmmin, mod.mean,  k = 2, REML = T)
mod.test$deltas <- round(mod.test$AICc-min(mod.test$AICc), 2)
mod.test$weights <- Weights(mod.test$AICc)
mod.test

#essentially all models are equally likely... calls for use of PC1-PC4?

```

## Does beta diversity correspond to temperature regime?
```{r plot.bd.temp}

plot.bd.temp <- function(metric) {
  acrdat <- data.frame(sample_data(phy.f.t.acropora))[, metric]
  pordat <- data.frame(sample_data(phy.f.t.porites))[, metric]
  plot(NA, xlim=range(acrdat), ylim=range(acr.bd$distances),
       xlab=paste(metric, "(by Site)"), ylab="Distance to centroid")
  acr.mod <- lm(acr.bd$distances ~ acrdat)
  acr.pval <- round(anova(acr.mod)$`Pr(>F)`[1], 3)
  por.mod <- lm(por.bd$distances ~ pordat)
  por.pval <- round(anova(por.mod)$`Pr(>F)`[1], 3)
  if (acr.pval < 0.05) {  # If slope is significantly different from 0
    abline(acr.mod, col="#d8b365")
    text(x=par("usr")[1], y=quantile(par("usr")[3:4], 0.9), pos=4, 
         labels=substitute(paste(italic("Acropora"), ": p=", acr.pval)),
         col="#d8b365")
  }
  if (por.pval < 0.05) {  # If slope is significantly different from 0
    abline(por.mod, col="#5ab4ac")
    text(x=par("usr")[1], y=quantile(par("usr")[3:4], 0.8), pos=4, 
         labels=substitute(paste(italic("Porites"), ": p=", por.pval)),
         col="#5ab4ac")
  }
  points(acr.bd$distances ~ acrdat, pch=24, bg="#d8b365", lwd=0.5)
  points(por.bd$distances ~ pordat, pch=25, bg="#5ab4ac", lwd=0.5)
}

# Plot beta diversity as a function of temperature PCs
par(mfrow=c(2,2), mar=c(2.5,2.5,1,1), mgp=c(1.5,0.3,0), tcl=-0.2)
plot.bd.temp("PC1")
plot.bd.temp("PC2")
plot.bd.temp("PC3")
plot.bd.temp("PC4")

# # Plot beta diversity as a function of original temperature metrics
# par(mfrow=c(2,2), mar=c(2.5,2.5,1,1), mgp=c(1.5,0.3,0), tcl=-0.2)
# plot.bd.temp("var")
# plot.bd.temp("mean")
# plot.bd.temp("dip")
# plot.bd.temp("daysover30")
# plot.bd.temp("daysunder27")
# plot.bd.temp("daily.mean.max")
# plot.bd.temp("daily.mean.min")
```

# Figure 4
```{r Fig4}
png("Output/Fig4.png", width=4, height=2, units="in", res=300)
par(mfrow=c(1,2), mar=c(2,2,1,1), mgp=c(1.1,0.1,0), tcl=0.2, 
    cex=0.6, cex.axis=0.8)
plot.bd.temp("PC1")
mtext(side=3, adj=-0.16, "A.", font=2, line=-0.3)
plot.bd.temp("PC2")
mtext(side=3, adj=-0.16, "B.", font=2, line=-0.3)
dev.off()
```

## Constrained ordination - do temperature metrics drive differences in community structure?
Above, we use unconstrained ordinations (PCoA and/or NMDS) to look for relationships between samples. The unconstrained ordinations, however, do not provide a direct link to potential environmental factors influencing sample community structure.  
Constrained ordination allows us to see how environmental variables (in our case, temperature metrics) are associated with changes in the community composition. In constrained ordination, the ordination axes are constrained to linear combinations of environmental variables.  
Below, we construct a constrained ordination using our PCA temperature metrics, to see if any linear combinations between them are significant. We look at this for Acropora and Porites separately. The first figure for each coral species is the scree plot of eigenvalues: essentially how much variability is explaned by each of the constrained axes (CAP1-CAP4) after the constrained axes, the scree plot shows variability explained by unconstrained axes (MDS1-MDS16) - residual variability caused by factors that we did not include in our model.  
After completing the ordination and plotting, we do a permutational ANOVA on constrained axes used in ordination. This tells us whether the model we have used is significant.  
Ordistep is an automatic stepwise model building tool that can be used to build constrained ordinations. This is used because "Actually, constrained ordination methods do not have AIC, and therefore the step may not be trusted. This function provides an alternative using permutation P-values. http://cc.oulu.fi/~jarioksa/softhelp/vegan/html/ordistep.html" Also "Function ordistep defines the model, scope of models considered, and direction of the procedure similarly as step. The function alternates with drop and add steps and stops when the model was not changed during one step. The - and + signs in the summary table indicate which stage is performed. The number of permutations is selected adaptively with respect to the defined decision limit."
```{r constrained_ordination temperature metrics}

# try each species individually
# PORITES
# First run model selection using PCs
ord.porites.CAP <- ordinate(phy.f.t.porites,method="CAP",distance="wunifrac",formula= ~ PC1 + PC2 + PC3 + PC4)
plot_ordination(phy.f.t.porites, ord.porites.CAP,  shape="Site",type="scree",
                title="97% within-sample OTUs - CAP Porites only")

plot_ordination(phy.f.t.porites, ord.porites.CAP, color="Site", shape="Site",
                title="97% within-sample OTUs - CAP Porites only")

anova(ord.porites.CAP)

# In a model with all 4 PCs included, this model (Porites, PCs 1-4) is not significant at p=0.05, but is at p=0.1

finalmodel.porites.PCs <- ordistep(ord.porites.CAP, formula= ~ PC1 + PC2 + PC3 + PC4, direction = c("both"), Pin = 0.05, Pout = 0.1, pstep = 100, perm.max = 1000, steps = 50, trace = TRUE)

finalmodel.porites.PCs
# With stepwise model selection, only PC1 is retained in the final model for Porites (PCs 1-4)

# Now, we test to make sure that this model holds up
#" Then, we can calculate Variance Inflation Factors (VIF) for each of the constraints (variables) from the "env" matrix (environmental matrix). If we find an environmental variable with VIF>10, we'll know that this variable presents colinearity with another or other variables. In that case, we would have to delete the variable from our initial dataset and redo all the analysis. http://rfunctions.blogspot.com/2016/11/canonical-correspondence-analysis-cca.html"
# There's only one retained variable, so this is actually not needed in this case. If there was more than one, then this would be important. 
vif.cca(finalmodel.porites.PCs)

# Now, we need to test whether our whole model, terms, and axes are significant (explain more variance of our observations than by chance)
# Testing the significance of the model:
anova.cca(finalmodel.porites.PCs)
# Testing the significance of terms (environmental variables):
anova.cca(finalmodel.porites.PCs, by="terms")
# Testing the significance of axes (at least the first two or three should present a significant p value):
anova.cca(finalmodel.porites.PCs, by="axis")
# Excellent, all of these test are significant. This means that the final model (Porites), distance ~ PC1 can be used.


# Next try model selection using temperature metrics
ord.porites.CAP2 <- ordinate(phy.f.t.porites,method="CAP",distance="wunifrac",formula= ~ mean+var+dip+daily.mean.min+daily.mean.max+daysover30+daysunder27)
plot_ordination(phy.f.t.porites, ord.porites.CAP2,  shape="Site",type="scree",
                title="97% within-sample OTUs - CAP Porites only")

plot_ordination(phy.f.t.porites, ord.porites.CAP2, color="Site", shape="Site",
                title="97% within-sample OTUs - CAP Porites only")

anova(ord.porites.CAP2)

# In a model with all 4 PCs included, this model (Porites, all temp metrics) is not significant at p=0.1

finalmodel.porites.alltempmetrics <- ordistep(ord.porites.CAP2, formula= ~ mean+var+dip+daily.mean.min+daily.mean.max+daysover30+daysunder27, direction = c("both"), Pin = 0.05, Pout = 0.1, pstep = 100, perm.max = 1000, steps = 50, trace = TRUE)

finalmodel.porites.alltempmetrics
# With stepwise model selection, only daysunder27 is retained in the final model for Porites (all temp metrics)

# Now, we test to make sure that this model holds up
# There's only one retained variable, so this is actually not needed in this case. If there was more than one, then this would be important. 
vif.cca(finalmodel.porites.alltempmetrics)

# Now, we need to test whether our whole model, terms, and axes are significant (explain more variance of our observations than by chance)
# Testing the significance of the model:
anova.cca(finalmodel.porites.alltempmetrics)
# Testing the significance of terms (environmental variables):
anova.cca(finalmodel.porites.alltempmetrics, by="terms")
# Testing the significance of axes (at least the first two or three should present a significant p value):
anova.cca(finalmodel.porites.alltempmetrics, by="axis")
# Excellent, all of these test are significant. This means that the final model (Porites), distance ~ daysunder27 can be used.




# ACROPORA
# First run model selection using PCs
ord.acropora.CAP <- ordinate(phy.f.t.acropora,method="CAP",distance="wunifrac",formula= ~ PC1 + PC2 + PC3 + PC4)
plot_ordination(phy.f.t.acropora, ord.acropora.CAP,  shape="Site",type="scree",
                title="97% within-sample OTUs - CAP Acropora only")

plot_ordination(phy.f.t.acropora, ord.acropora.CAP, color="Site", shape="Site",
                title="97% within-sample OTUs - CAP Acropora only")

anova(ord.acropora.CAP)

# In a model with all 4 PCs included, this model (Acropora, PCs 1-4) is significant at p=0.05


finalmodel.acropora.PCs<-ordistep(ord.acropora.CAP, formula= ~ PC1 + PC2 + PC3 + PC4, direction = c("both"), Pin = 0.05, Pout = 0.1, pstep = 100, perm.max = 1000, steps = 50, trace = TRUE)

finalmodel.acropora.PCs
# With stepwise model selection, PC2 and PC4 are retained in the final model for Acropora (PCs 1-4)

# Now, we test to make sure that this model holds up
vif.cca(finalmodel.acropora.PCs)
# These are <10, so are not collinear. This makes sense, as we are using PCs, and they, by nature, should not be collinear...

# Now, we need to test whether our whole model, terms, and axes are significant (explain more variance of our observations than by chance)
# Testing the significance of the model:
anova.cca(finalmodel.acropora.PCs)
# Testing the significance of terms (environmental variables):
anova.cca(finalmodel.acropora.PCs, by="terms")
# Testing the significance of axes (at least the first two or three should present a significant p value):
# anova.cca(finalmodel.acropora.PCs, by="axis") # For some reason this one doesn't work?
# These test are significant. This means that the final model (Acropora), distance ~ PC2 + PC4 can be used.


# Now we can look at individual temperature metrics (rather than PCs)
ord.acropora.CAP2 <- ordinate(phy.f.t.acropora,method="CAP",distance="wunifrac",formula= ~ mean+var+dip+daily.mean.min+daily.mean.max+daysover30+daysunder27)
plot_ordination(phy.f.t.acropora, ord.acropora.CAP2,  shape="Site",type="scree",
                title="97% within-sample OTUs - CAP acropora only")

plot_ordination(phy.f.t.acropora, ord.acropora.CAP2, color="Site", shape="Site",
                title="97% within-sample OTUs - CAP acropora only")

anova(ord.acropora.CAP2)

# In a model with all temp metrics included, this model (Acropora, all temp metrics) is significant at p=0.05

finalmodel.acropora.alltempmetrics<-ordistep(ord.acropora.CAP2, formula= ~ mean+var+dip+daily.mean.min+daily.mean.max+daysover30+daysunder27, direction = c("both"), Pin = 0.05, Pout = 0.1, pstep = 100, perm.max = 1000, steps = 50, trace = TRUE)

finalmodel.acropora.alltempmetrics
# With stepwise model selection, mean+daily.mean.min+daysover30+daysunder27 were retained in the final model for Acropora (all temp metrics)

# Now, we test to make sure that this model holds up
vif.cca(finalmodel.acropora.alltempmetrics)
# These metrics are correlated. This is problematic, and may suggest that our PC approach is indeed better, as we deal with collinearity before ordination.

```

## New idea for analysis: how much of the variability in Symbiodinium communities can be explained by "Site" alone?
```{r constrained_ordination site}

acropora.CAP.site <- ordinate(phy.f.t.acropora, method="CAP", distance="wunifrac",
                              formula= ~ factor(Site))
plot_ordination(phy.f.t.acropora, acropora.CAP.site, type="scree")
explained.by.site <- with(summary(acropora.CAP.site), constr.chi/tot.chi)
acropora.CAP.temp <- ordinate(phy.f.t.acropora, method="CAP", distance="wunifrac",
                              formula= ~ PC1 + PC2 + PC3 + PC4)
acropora.CAP.temp <- ordinate(phy.f.t.acropora, method="CAP", distance="wunifrac",
                              formula= ~ mean + var + daysover30 + daysunder27 +
                                         daily.mean.min + daily.mean.max + dip)
plot_ordination(phy.f.t.acropora, acropora.CAP.temp, type="scree")
explained.by.temp <- with(summary(acropora.CAP.temp), constr.chi/tot.chi)

# How much of the variability explained by Site can be explained by Temp?
explained.by.temp / explained.by.site
# 100%? something seems fishy.



# New idea for analysis: how much of the variability in Symbiodinium communities can be explained by "Site" alone?
porites.CAP.site <- ordinate(phy.f.t.porites,method="CAP",distance="wunifrac",formula= ~ Site)
explained.by.site <- with(summary(porites.CAP.site), constr.chi/tot.chi)
porites.CAP.temp <- ordinate(phy.f.t.porites,method="CAP",distance="wunifrac",formula= ~ PC1 + PC2 + PC3 + PC4)
porites.CAP.temp <- ordinate(phy.f.t.porites,method="CAP",distance="wunifrac",formula= ~ mean + var + daysover30 + daysunder27 + daily.mean.min + daily.mean.max + dip)
explained.by.temp <- with(summary(porites.CAP.temp), constr.chi/tot.chi)

# How much of the variability explained by Site can be explained by Temp?
explained.by.temp / explained.by.site

```